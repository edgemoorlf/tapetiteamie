<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è¯­éŸ³äº¤äº’è§†é¢‘æ’­æ”¾å™¨ (Streaming)</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      max-width: 900px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 30px;
      font-size: 2em;
    }

    .video-container {
      position: relative;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    video {
      width: 100%;
      display: block;
    }

    .voice-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 30px 40px;
      border-radius: 15px;
      text-align: center;
      display: none;
      z-index: 10;
    }

    .voice-prompt.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    .mic-icon {
      font-size: 48px;
      margin-bottom: 15px;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    button {
      flex: 1;
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      min-width: 120px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .mode-toggle {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      font-size: 14px;
      min-width: 160px;
    }

    .transcript-log {
      margin-top: 20px;
      background: #f9f9f9;
      border-radius: 10px;
      padding: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    .transcript-log h3 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    .transcript-content {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #333;
      line-height: 1.6;
    }

    .transcript-entry {
      padding: 8px;
      margin-bottom: 8px;
      background: white;
      border-radius: 5px;
      border-left: 3px solid #667eea;
    }

    .transcript-entry.browser {
      border-left-color: #f5576c;
    }

    .transcript-entry .timestamp {
      color: #999;
      font-size: 11px;
      margin-right: 8px;
    }

    .transcript-entry .mode-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: bold;
      margin-right: 8px;
    }

    .transcript-entry .mode-badge.dashscope {
      background: #667eea;
      color: white;
    }

    .transcript-entry .mode-badge.browser {
      background: #f5576c;
      color: white;
    }

    .video-list {
      margin-top: 20px;
    }

    .video-list h3 {
      color: #667eea;
      margin-bottom: 15px;
    }

    .video-item {
      padding: 12px;
      background: #f5f5f5;
      margin-bottom: 8px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .video-item:hover {
      background: #e0e0e0;
    }

    .video-item.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .status {
      text-align: center;
      padding: 15px;
      border-radius: 10px;
      margin-top: 15px;
      background: #f0f0f0;
      color: #666;
    }

    .status.listening {
      background: #fff3cd;
      color: #856404;
    }

    .status.processing {
      background: #d1ecf1;
      color: #0c5460;
    }

    .preload-info {
      font-size: 12px;
      color: #999;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¬ è¯­éŸ³äº¤äº’è§†é¢‘æ’­æ”¾å™¨</h1>
    
    <div class="video-container">
      <video id="mainVideo" preload="auto"></video>
      <div id="voicePrompt" class="voice-prompt">
        <div class="mic-icon">ğŸ¤</div>
        <h2>è¯·è¯´å‡ºä½ æƒ³æ’­æ”¾çš„è§†é¢‘...</h2>
        <p>ä¾‹å¦‚ï¼š"è§†é¢‘1"ã€"ç¬¬äºŒä¸ª"</p>
      </div>
    </div>

    <div class="controls">
      <button id="playBtn">â–¶ æ’­æ”¾</button>
      <button id="pauseBtn">â¸ æš‚åœ</button>
      <button id="testVoiceBtn">ğŸ¤ æµ‹è¯•è¯­éŸ³</button>
      <button id="toggleModeBtn" class="mode-toggle">æ¨¡å¼: DashScope</button>
    </div>

    <div id="status" class="status">å‡†å¤‡å°±ç»ª</div>

    <div class="transcript-log">
      <h3>ğŸ“ è¯†åˆ«è®°å½•</h3>
      <div id="transcriptLog" class="transcript-content"></div>
    </div>

    <div class="video-list">
      <h3>ğŸ“¹ å¯ç”¨è§†é¢‘åˆ—è¡¨</h3>
      <div id="videoListContainer"></div>
      <div class="preload-info">* è§†é¢‘ä¼šåœ¨æ’­æ”¾å‰è‡ªåŠ¨é¢„åŠ è½½ä»¥ç¡®ä¿æµç•…åˆ‡æ¢</div>
    </div>
  </div>

  <script>
    // ============================================================================
    // Video Matching System - Modular Architecture
    // ============================================================================

    /**
     * Base class for video matching strategies
     */
    class VideoMatchStrategy {
      constructor(name, priority = 50) {
        this.name = name;
        this.priority = priority; // Higher priority = checked first
      }

      /**
       * Attempt to match transcript to a video
       * @param {string} transcript - The recognized speech text
       * @param {Array} videos - Array of video objects
       * @param {Object} context - Additional context (currentIndex, etc.)
       * @returns {Object|null} - {index: number, confidence: number, reason: string} or null
       */
      match(transcript, videos, context) {
        throw new Error('match() must be implemented by subclass');
      }
    }

    /**
     * Strategy 1: Match by video filename
     */
    class FilenameMatchStrategy extends VideoMatchStrategy {
      constructor() {
        super('Filename Match', 80);
      }

      match(transcript, videos, context) {
        const cleanTranscript = transcript.toLowerCase().trim();

        for (let i = 0; i < videos.length; i++) {
          // Remove extension and convert to lowercase
          const filename = videos[i].name.replace(/\.[^/.]+$/, '').toLowerCase();

          if (cleanTranscript.includes(filename)) {
            return {
              index: i,
              confidence: 0.9,
              reason: `Filename match: "${filename}"`
            };
          }
        }
        return null;
      }
    }

    /**
     * Strategy 2: Match by numeric patterns (è§†é¢‘1, ç¬¬äºŒä¸ª, etc.)
     */
    class NumericMatchStrategy extends VideoMatchStrategy {
      constructor() {
        super('Numeric Match', 70);
        this.chineseNumbers = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å'];
      }

      numberToChinese(num) {
        return this.chineseNumbers[num - 1] || num.toString();
      }

      match(transcript, videos, context) {
        const cleanTranscript = transcript.toLowerCase().trim();

        for (let i = 0; i < videos.length; i++) {
          const index = i + 1;

          // Pattern 1: "è§†é¢‘1", "è§†é¢‘2"
          if (cleanTranscript.includes(`è§†é¢‘${index}`)) {
            return {
              index: i,
              confidence: 0.95,
              reason: `Numeric pattern: "è§†é¢‘${index}"`
            };
          }

          // Pattern 2: "ç¬¬ä¸€ä¸ª", "ç¬¬äºŒä¸ª"
          if (cleanTranscript.includes(`ç¬¬${this.numberToChinese(index)}ä¸ª`)) {
            return {
              index: i,
              confidence: 0.95,
              reason: `Chinese ordinal: "ç¬¬${this.numberToChinese(index)}ä¸ª"`
            };
          }

          // Pattern 3: Direct number "1", "2"
          if (cleanTranscript === `${index}`) {
            return {
              index: i,
              confidence: 0.85,
              reason: `Direct number: "${index}"`
            };
          }
        }
        return null;
      }
    }

    /**
     * Strategy 3: Match by video transcript content
     */
    class TranscriptMatchStrategy extends VideoMatchStrategy {
      constructor() {
        super('Transcript Match', 100); // Highest priority
      }

      match(transcript, videos, context) {
        const cleanTranscript = transcript.toLowerCase().trim();

        for (let i = 0; i < videos.length; i++) {
          const video = videos[i];

          // Check if video has transcript metadata
          if (!video.transcript) continue;

          const videoTranscript = video.transcript.toLowerCase();

          // Match against beginning of video transcript (first 100 chars)
          const beginning = videoTranscript.substring(0, 100);

          // Check for significant word overlap
          const words = cleanTranscript.split(/\s+/).filter(w => w.length > 1);
          let matchCount = 0;

          for (const word of words) {
            if (beginning.includes(word)) {
              matchCount++;
            }
          }

          // If more than 50% of words match, consider it a match
          if (words.length > 0 && matchCount / words.length > 0.5) {
            return {
              index: i,
              confidence: matchCount / words.length,
              reason: `Transcript match: ${matchCount}/${words.length} words in beginning`
            };
          }

          // Also check full transcript with lower confidence
          matchCount = 0;
          for (const word of words) {
            if (videoTranscript.includes(word)) {
              matchCount++;
            }
          }

          if (words.length > 0 && matchCount / words.length > 0.6) {
            return {
              index: i,
              confidence: (matchCount / words.length) * 0.8,
              reason: `Transcript match: ${matchCount}/${words.length} words in full transcript`
            };
          }
        }
        return null;
      }
    }

    /**
     * Video Matcher - Coordinates all matching strategies
     */
    class VideoMatcher {
      constructor() {
        this.strategies = [];
        this.matchHistory = [];
      }

      /**
       * Register a matching strategy
       */
      addStrategy(strategy) {
        this.strategies.push(strategy);
        // Sort by priority (highest first)
        this.strategies.sort((a, b) => b.priority - a.priority);
      }

      /**
       * Find best matching video for transcript
       */
      findMatch(transcript, videos, context = {}) {
        const results = [];

        // Try all strategies
        for (const strategy of this.strategies) {
          try {
            const result = strategy.match(transcript, videos, context);
            if (result) {
              results.push({
                ...result,
                strategy: strategy.name
              });
            }
          } catch (error) {
            console.error(`Strategy ${strategy.name} failed:`, error);
          }
        }

        // No matches found
        if (results.length === 0) {
          this.logMatch(transcript, null, 'No match found');
          return null;
        }

        // Sort by confidence (highest first)
        results.sort((a, b) => b.confidence - a.confidence);

        // Return best match
        const bestMatch = results[0];
        this.logMatch(transcript, bestMatch, 'Match found');

        return bestMatch;
      }

      /**
       * Log matching attempt for debugging
       */
      logMatch(transcript, result, status) {
        const entry = {
          timestamp: new Date().toISOString(),
          transcript,
          result,
          status
        };

        this.matchHistory.push(entry);

        // Keep only last 50 entries
        if (this.matchHistory.length > 50) {
          this.matchHistory.shift();
        }

        // Console log
        if (result) {
          console.log(`[VideoMatcher] âœ… ${status}:`, {
            transcript,
            videoIndex: result.index,
            confidence: (result.confidence * 100).toFixed(1) + '%',
            strategy: result.strategy,
            reason: result.reason
          });
        } else {
          console.log(`[VideoMatcher] âŒ ${status}:`, { transcript });
        }
      }

      /**
       * Get match history for debugging
       */
      getHistory() {
        return this.matchHistory;
      }
    }

    // ============================================================================
    // Main Application
    // ============================================================================

    class VoiceVideoPlayer {
      constructor() {
        this.mainVideo = document.getElementById('mainVideo');
        this.voicePrompt = document.getElementById('voicePrompt');
        this.status = document.getElementById('status');
        this.videoListContainer = document.getElementById('videoListContainer');
        this.transcriptLog = document.getElementById('transcriptLog');

        this.videos = [];
        this.currentIndex = 0;
        this.preloadedVideos = new Map();
        this.isListening = false;

        // Recognition mode: 'dashscope' or 'browser'
        this.recognitionMode = 'dashscope';

        // WebSocket and streaming audio (for DashScope)
        this.socket = null;
        this.audioContext = null;
        this.mediaStream = null;
        this.scriptProcessor = null;

        // Browser-based recognition (Web Speech API)
        this.browserRecognition = null;

        // Initialize video matcher with strategies
        this.videoMatcher = new VideoMatcher();
        this.videoMatcher.addStrategy(new TranscriptMatchStrategy());
        this.videoMatcher.addStrategy(new FilenameMatchStrategy());
        this.videoMatcher.addStrategy(new NumericMatchStrategy());

        this.init();
      }

      async init() {
        await this.loadVideos();
        this.setupEventListeners();
        this.preloadNextVideos();
        this.initWebSocket();
        this.initBrowserRecognition();
      }

      initWebSocket() {
        // Connect to WebSocket server for DashScope
        this.socket = io('http://localhost:5001');

        this.socket.on('connected', (data) => {
          console.log('WebSocket connected:', data);
          this.logTranscript('ç³»ç»Ÿ', 'WebSocket å·²è¿æ¥', 'dashscope');
        });

        this.socket.on('recognition_started', (data) => {
          console.log('Recognition started:', data);
        });

        this.socket.on('recognition_result', (data) => {
          console.log('Recognition result:', data);
          if (data.transcript) {
            this.updateStatus(`ğŸ¤ è¯†åˆ«ä¸­: "${data.transcript}"`);
            this.logTranscript('éƒ¨åˆ†ç»“æœ', data.transcript, 'dashscope');
          }
        });

        this.socket.on('recognition_complete', (data) => {
          console.log('Recognition complete:', data);
          this.logTranscript('æœ€ç»ˆç»“æœ', data.transcript, 'dashscope');
          this.handleRecognitionComplete(data.transcript);
        });

        this.socket.on('recognition_error', (data) => {
          console.error('Recognition error:', data);
          this.updateStatus('âŒ è¯†åˆ«é”™è¯¯: ' + data.error);
          this.logTranscript('é”™è¯¯', data.error, 'dashscope');
          this.hideVoicePrompt();
          this.stopVoiceRecognition();
        });

        this.socket.on('recognition_closed', (data) => {
          console.log('Recognition closed:', data);
        });
      }

      initBrowserRecognition() {
        // Initialize Web Speech API
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          console.warn('Browser does not support Web Speech API');
          return;
        }

        this.browserRecognition = new SpeechRecognition();
        this.browserRecognition.lang = 'zh-CN';
        this.browserRecognition.continuous = false;
        this.browserRecognition.interimResults = true;

        this.browserRecognition.onstart = () => {
          console.log('Browser recognition started');
          this.updateStatus('ğŸ¤ æ­£åœ¨å¬... (æµè§ˆå™¨è¯†åˆ«)', 'listening');
        };

        this.browserRecognition.onresult = (event) => {
          let interimTranscript = '';
          let finalTranscript = '';

          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalTranscript += transcript;
              this.logTranscript('æœ€ç»ˆç»“æœ', transcript, 'browser');
            } else {
              interimTranscript += transcript;
              this.logTranscript('éƒ¨åˆ†ç»“æœ', transcript, 'browser');
            }
          }

          if (interimTranscript) {
            this.updateStatus(`ğŸ¤ è¯†åˆ«ä¸­: "${interimTranscript}"`);
          }

          if (finalTranscript) {
            console.log('Browser recognition final:', finalTranscript);
            this.handleRecognitionComplete(finalTranscript);
          }
        };

        this.browserRecognition.onerror = (event) => {
          console.error('Browser recognition error:', event.error);
          this.updateStatus('âŒ æµè§ˆå™¨è¯†åˆ«é”™è¯¯: ' + event.error);
          this.logTranscript('é”™è¯¯', event.error, 'browser');
          this.hideVoicePrompt();
          this.isListening = false;
        };

        this.browserRecognition.onend = () => {
          console.log('Browser recognition ended');
          this.isListening = false;
        };
      }

      logTranscript(label, text, mode) {
        const timestamp = new Date().toLocaleTimeString('zh-CN');
        const entry = document.createElement('div');
        entry.className = `transcript-entry ${mode}`;

        const modeBadge = mode === 'dashscope' ? 'DashScope' : 'æµè§ˆå™¨';
        const modeClass = mode === 'dashscope' ? 'dashscope' : 'browser';

        entry.innerHTML = `
          <span class="timestamp">${timestamp}</span>
          <span class="mode-badge ${modeClass}">${modeBadge}</span>
          <strong>${label}:</strong> ${text}
        `;

        this.transcriptLog.appendChild(entry);
        this.transcriptLog.scrollTop = this.transcriptLog.scrollHeight;

        // Also log to console
        console.log(`[${mode.toUpperCase()}] ${label}: ${text}`);
      }

      toggleRecognitionMode() {
        this.recognitionMode = this.recognitionMode === 'dashscope' ? 'browser' : 'dashscope';
        const modeBtn = document.getElementById('toggleModeBtn');

        if (this.recognitionMode === 'dashscope') {
          modeBtn.textContent = 'æ¨¡å¼: DashScope';
          modeBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          this.updateStatus('å·²åˆ‡æ¢åˆ° DashScope æµå¼è¯†åˆ«æ¨¡å¼');
        } else {
          modeBtn.textContent = 'æ¨¡å¼: æµè§ˆå™¨';
          modeBtn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
          this.updateStatus('å·²åˆ‡æ¢åˆ°æµè§ˆå™¨å†…ç½®è¯†åˆ«æ¨¡å¼');
        }

        this.logTranscript('ç³»ç»Ÿ', `åˆ‡æ¢åˆ° ${this.recognitionMode === 'dashscope' ? 'DashScope' : 'æµè§ˆå™¨'} æ¨¡å¼`, this.recognitionMode);
      }

      async loadVideos() {
        try {
          const response = await fetch('/api/videos');
          this.videos = await response.json();

          if (this.videos.length === 0) {
            this.updateStatus('è¯·åœ¨ videos ç›®å½•ä¸­æ·»åŠ  mp4 è§†é¢‘æ–‡ä»¶');
            return;
          }

          this.renderVideoList();
          this.loadVideo(0);
          this.updateStatus(`å·²åŠ è½½ ${this.videos.length} ä¸ªè§†é¢‘ (æµå¼è¯†åˆ«æ¨¡å¼)`);
        } catch (error) {
          this.updateStatus('åŠ è½½è§†é¢‘åˆ—è¡¨å¤±è´¥: ' + error.message);
        }
      }

      renderVideoList() {
        this.videoListContainer.innerHTML = '';
        this.videos.forEach((video, index) => {
          const div = document.createElement('div');
          div.className = 'video-item';
          div.innerHTML = `
            <span>${index + 1}. ${video.name}</span>
            <span style="font-size: 12px; color: #999;">ç‚¹å‡»æ’­æ”¾</span>
          `;
          div.addEventListener('click', () => this.loadVideo(index));
          this.videoListContainer.appendChild(div);
        });
      }

      loadVideo(index) {
        if (index < 0 || index >= this.videos.length) return;

        this.currentIndex = index;
        const video = this.videos[index];

        if (this.preloadedVideos.has(index)) {
          this.mainVideo.src = this.preloadedVideos.get(index);
        } else {
          this.mainVideo.src = video.url;
        }

        this.mainVideo.load();
        this.updateVideoListUI();
        this.updateStatus(`æ­£åœ¨æ’­æ”¾: ${video.name}`);

        this.preloadNextVideos();
      }

      preloadNextVideos() {
        for (let i = 1; i <= 2; i++) {
          const nextIndex = (this.currentIndex + i) % this.videos.length;
          if (!this.preloadedVideos.has(nextIndex)) {
            this.preloadVideo(nextIndex);
          }
        }
      }

      preloadVideo(index) {
        if (index < 0 || index >= this.videos.length) return;

        const video = this.videos[index];
        const preloadVideo = document.createElement('video');
        preloadVideo.preload = 'auto';
        preloadVideo.src = video.url;

        this.preloadedVideos.set(index, video.url);

        console.log(`é¢„åŠ è½½è§†é¢‘ ${index + 1}: ${video.name}`);
      }

      updateVideoListUI() {
        const items = this.videoListContainer.querySelectorAll('.video-item');
        items.forEach((item, index) => {
          item.classList.toggle('active', index === this.currentIndex);
        });
      }

      setupEventListeners() {
        this.mainVideo.addEventListener('ended', () => {
          this.showVoicePrompt();
          this.startVoiceRecognition();
        });

        document.getElementById('playBtn').addEventListener('click', () => {
          this.mainVideo.play();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
          this.mainVideo.pause();
        });

        document.getElementById('testVoiceBtn').addEventListener('click', () => {
          this.showVoicePrompt();
          this.startVoiceRecognition();
        });

        document.getElementById('toggleModeBtn').addEventListener('click', () => {
          this.toggleRecognitionMode();
        });
      }

      showVoicePrompt() {
        this.voicePrompt.classList.add('active');
      }

      hideVoicePrompt() {
        this.voicePrompt.classList.remove('active');
      }

      async startVoiceRecognition() {
        if (this.isListening) return;

        if (this.recognitionMode === 'browser') {
          this.startBrowserRecognition();
        } else {
          this.startDashScopeRecognition();
        }
      }

      startBrowserRecognition() {
        if (!this.browserRecognition) {
          this.updateStatus('âŒ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
          this.hideVoicePrompt();
          return;
        }

        try {
          this.isListening = true;
          this.browserRecognition.start();
          this.logTranscript('ç³»ç»Ÿ', 'å¼€å§‹æµè§ˆå™¨è¯­éŸ³è¯†åˆ«', 'browser');
        } catch (error) {
          this.updateStatus('æµè§ˆå™¨è¯†åˆ«å¯åŠ¨å¤±è´¥: ' + error.message);
          this.logTranscript('é”™è¯¯', error.message, 'browser');
          this.hideVoicePrompt();
          this.isListening = false;
        }
      }

      async startDashScopeRecognition() {
        if (this.isListening) return;

        try {
          // Get microphone access
          this.mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });

          this.isListening = true;
          this.updateStatus('ğŸ¤ æ­£åœ¨å¬... (DashScope æµå¼è¯†åˆ«)', 'listening');
          this.logTranscript('ç³»ç»Ÿ', 'å¼€å§‹ DashScope æµå¼è¯†åˆ«', 'dashscope');

          // Create AudioContext (let browser choose sample rate, we'll resample)
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

          console.log(`AudioContext sample rate: ${this.audioContext.sampleRate} Hz`);

          const source = this.audioContext.createMediaStreamSource(this.mediaStream);

          // Use ScriptProcessorNode for audio processing
          const bufferSize = 4096;
          this.scriptProcessor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);

          let frameCount = 0;

          this.scriptProcessor.onaudioprocess = (e) => {
            if (!this.isListening) return;

            const inputData = e.inputBuffer.getChannelData(0);

            // Debug: Log first frame
            if (frameCount === 0) {
              console.log('First audio frame:', {
                length: inputData.length,
                sampleRate: this.audioContext.sampleRate,
                firstSamples: Array.from(inputData.slice(0, 10)),
                max: Math.max(...inputData),
                min: Math.min(...inputData)
              });
            }
            frameCount++;

            // Resample to 16kHz if needed
            let resampledData = inputData;
            if (this.audioContext.sampleRate !== 16000) {
              resampledData = this.resample(inputData, this.audioContext.sampleRate, 16000);
            }

            // Convert Float32Array to Int16Array (PCM)
            const pcmData = this.float32ToInt16(resampledData);

            // Send PCM data to server via WebSocket
            if (this.socket && this.socket.connected) {
              this.socket.emit('audio_data', { audio: Array.from(pcmData) });
            }
          };

          source.connect(this.scriptProcessor);
          this.scriptProcessor.connect(this.audioContext.destination);

          // Start recognition on server
          this.socket.emit('start_recognition', {});

          // Stop after 5 seconds
          setTimeout(() => {
            if (this.isListening) {
              this.stopVoiceRecognition();
            }
          }, 5000);

        } catch (error) {
          this.updateStatus('éº¦å…‹é£è®¿é—®å¤±è´¥: ' + error.message);
          this.logTranscript('é”™è¯¯', 'éº¦å…‹é£è®¿é—®å¤±è´¥: ' + error.message, 'dashscope');
          this.hideVoicePrompt();
          this.isListening = false;
        }
      }

      stopVoiceRecognition() {
        if (!this.isListening) return;

        this.isListening = false;
        this.updateStatus('ğŸ”„ æ­£åœ¨å¤„ç†è¯­éŸ³...', 'processing');

        if (this.recognitionMode === 'browser') {
          // Stop browser recognition
          if (this.browserRecognition) {
            try {
              this.browserRecognition.stop();
            } catch (e) {
              console.log('Browser recognition already stopped');
            }
          }
        } else {
          // Stop DashScope recognition
          // Stop audio processing
          if (this.scriptProcessor) {
            this.scriptProcessor.disconnect();
            this.scriptProcessor = null;
          }

          if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
          }

          if (this.mediaStream) {
            this.mediaStream.getTracks().forEach(track => track.stop());
            this.mediaStream = null;
          }

          // Stop recognition on server
          if (this.socket && this.socket.connected) {
            this.socket.emit('stop_recognition', {});
          }
        }
      }

      float32ToInt16(float32Array) {
        const int16Array = new Int16Array(float32Array.length);
        for (let i = 0; i < float32Array.length; i++) {
          const s = Math.max(-1, Math.min(1, float32Array[i]));
          int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return int16Array;
      }

      resample(audioData, fromSampleRate, toSampleRate) {
        // Simple linear interpolation resampling
        if (fromSampleRate === toSampleRate) {
          return audioData;
        }

        const ratio = fromSampleRate / toSampleRate;
        const newLength = Math.round(audioData.length / ratio);
        const result = new Float32Array(newLength);

        for (let i = 0; i < newLength; i++) {
          const position = i * ratio;
          const index = Math.floor(position);
          const fraction = position - index;

          if (index + 1 < audioData.length) {
            // Linear interpolation
            result[i] = audioData[index] * (1 - fraction) + audioData[index + 1] * fraction;
          } else {
            result[i] = audioData[index];
          }
        }

        return result;
      }

      handleRecognitionComplete(transcript) {
        this.hideVoicePrompt();

        if (!transcript || transcript.trim() === '') {
          this.updateStatus('âš ï¸ æœªèƒ½è¯†åˆ«è¯­éŸ³å†…å®¹ï¼Œæ’­æ”¾ä¸‹ä¸€ä¸ª');
          setTimeout(() => {
            this.playNext();
          }, 2000);
          return;
        }

        const cleanTranscript = transcript.trim().toLowerCase();
        this.updateStatus(`âœ… è¯†åˆ«ç»“æœ: "${cleanTranscript}"`);

        // Use VideoMatcher to find best match
        const match = this.videoMatcher.findMatch(cleanTranscript, this.videos, {
          currentIndex: this.currentIndex
        });

        if (match) {
          // Log match details
          this.logTranscript(
            'åŒ¹é…ç»“æœ',
            `è§†é¢‘ #${match.index + 1} (${match.strategy}, ç½®ä¿¡åº¦: ${(match.confidence * 100).toFixed(1)}%)`,
            this.recognitionMode
          );

          this.updateStatus(
            `âœ… åŒ¹é…åˆ°è§†é¢‘ #${match.index + 1}: ${this.videos[match.index].name} (${(match.confidence * 100).toFixed(1)}% ç½®ä¿¡åº¦)`
          );

          setTimeout(() => {
            this.loadVideo(match.index);
            this.mainVideo.play();
          }, 1000);
        } else {
          this.logTranscript('åŒ¹é…ç»“æœ', 'æœªæ‰¾åˆ°åŒ¹é…ï¼Œæ’­æ”¾ä¸‹ä¸€ä¸ª', this.recognitionMode);
          this.updateStatus(`æœªæ‰¾åˆ°åŒ¹é…çš„è§†é¢‘ "${cleanTranscript}"ï¼Œæ’­æ”¾ä¸‹ä¸€ä¸ª`);
          setTimeout(() => {
            this.playNext();
          }, 2000);
        }
      }

      playNext() {
        const nextIndex = (this.currentIndex + 1) % this.videos.length;
        this.loadVideo(nextIndex);
        this.mainVideo.play();
      }

      updateStatus(message, className = '') {
        this.status.textContent = message;
        this.status.className = 'status ' + className;
      }
    }

    // Initialize player
    const player = new VoiceVideoPlayer();
  </script>
</body>
</html>