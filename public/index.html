<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ËØ≠Èü≥‰∫§‰∫íËßÜÈ¢ë</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      max-width: 900px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 30px;
      font-size: 2em;
    }

    .video-container {
      position: relative;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    video {
      width: 100%;
      display: block;
    }

    .voice-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 30px 40px;
      border-radius: 15px;
      text-align: center;
      display: none;
      z-index: 10;
    }

    .voice-prompt.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    .mic-icon {
      font-size: 48px;
      margin-bottom: 15px;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    button {
      flex: 1;
      padding: 12px 24px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      min-width: 120px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .mode-toggle {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      font-size: 14px;
      min-width: 160px;
    }

    .transcript-log {
      margin-top: 20px;
      background: #f9f9f9;
      border-radius: 10px;
      padding: 15px;
      max-height: 200px;
      overflow-y: auto;
    }

    .transcript-log h3 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    .transcript-content {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #333;
      line-height: 1.6;
    }

    .transcript-entry {
      padding: 8px;
      margin-bottom: 8px;
      background: white;
      border-radius: 5px;
      border-left: 3px solid #667eea;
    }

    .transcript-entry.browser {
      border-left-color: #f5576c;
    }

    .transcript-entry .timestamp {
      color: #999;
      font-size: 11px;
      margin-right: 8px;
    }

    .transcript-entry .mode-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: bold;
      margin-right: 8px;
    }

    .transcript-entry .mode-badge.dashscope {
      background: #667eea;
      color: white;
    }

    .transcript-entry .mode-badge.browser {
      background: #f5576c;
      color: white;
    }

    .video-list {
      margin-top: 20px;
    }

    .video-list h3 {
      color: #667eea;
      margin-bottom: 15px;
    }

    .video-item {
      padding: 12px;
      background: #f5f5f5;
      margin-bottom: 8px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .video-item:hover {
      background: #e0e0e0;
    }

    .video-item.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .status {
      text-align: center;
      padding: 15px;
      border-radius: 10px;
      margin-top: 15px;
      background: #f0f0f0;
      color: #666;
    }

    .status.listening {
      background: #fff3cd;
      color: #856404;
    }

    .status.processing {
      background: #d1ecf1;
      color: #0c5460;
    }

    .preload-info {
      font-size: 12px;
      color: #999;
      margin-top: 5px;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        padding: 10px;
        align-items: flex-start;
      }

      .container {
        padding: 15px;
        border-radius: 15px;
        max-width: 100%;
      }

      h1 {
        font-size: 1.5em;
        margin-bottom: 15px;
      }

      .video-container {
        border-radius: 10px;
        margin-bottom: 15px;
      }

      .voice-prompt {
        padding: 20px 25px;
        border-radius: 10px;
      }

      .mic-icon {
        font-size: 36px;
        margin-bottom: 10px;
      }

      .controls {
        gap: 10px;
        margin-bottom: 15px;
      }

      button {
        padding: 14px 20px;
        font-size: 15px;
        min-width: 100px;
        border-radius: 8px;
        /* Larger tap targets for mobile */
        min-height: 48px;
      }

      .mode-toggle {
        font-size: 13px;
        min-width: 140px;
      }

      .transcript-log {
        margin-top: 15px;
        padding: 12px;
        max-height: 150px;
        border-radius: 8px;
      }

      .transcript-log h3 {
        font-size: 1em;
        margin-bottom: 8px;
      }

      .transcript-content {
        font-size: 12px;
      }

      .transcript-entry {
        padding: 6px;
        margin-bottom: 6px;
      }

      .video-list {
        margin-top: 15px;
      }

      .video-list h3 {
        font-size: 1em;
        margin-bottom: 10px;
      }

      .video-item {
        padding: 10px;
        margin-bottom: 6px;
        border-radius: 6px;
        font-size: 14px;
      }

      .status {
        padding: 12px;
        margin-top: 12px;
        font-size: 14px;
        border-radius: 8px;
      }

      .preload-info {
        font-size: 11px;
      }
    }

    /* Extra small mobile devices */
    @media (max-width: 480px) {
      body {
        padding: 5px;
      }

      .container {
        padding: 10px;
        border-radius: 10px;
      }

      h1 {
        font-size: 1.3em;
        margin-bottom: 12px;
      }

      .controls {
        flex-direction: column;
        gap: 8px;
      }

      button {
        width: 100%;
        min-width: auto;
      }

      .transcript-log {
        max-height: 120px;
        padding: 10px;
      }

      .transcript-content {
        font-size: 11px;
      }

      .video-item {
        font-size: 13px;
        padding: 8px;
      }
    }

    /* Fullscreen Mode Styles */
    .fullscreen-mode {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 9999;
      display: none;
    }

    .fullscreen-mode.active {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .fullscreen-mode video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .fullscreen-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-mode:hover .fullscreen-controls,
    .fullscreen-controls.visible {
      opacity: 1;
    }

    .fullscreen-controls button {
      padding: 15px 25px;
      font-size: 18px;
      border-radius: 50px;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      min-height: 56px;
      min-width: 56px;
    }

    .fullscreen-controls button:active {
      background: rgba(255, 255, 255, 0.4);
      transform: scale(0.95);
    }

    .fullscreen-controls button.listening {
      background: rgba(255, 59, 48, 0.8);
      border-color: rgba(255, 59, 48, 1);
      animation: pulse-red 1.5s infinite;
    }

    @keyframes pulse-red {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7);
      }
      50% {
        box-shadow: 0 0 0 15px rgba(255, 59, 48, 0);
      }
    }

    .fullscreen-status {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 16px;
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-status.visible {
      opacity: 1;
    }

    .fullscreen-transcript {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      color: white;
      padding: 15px 30px;
      border-radius: 15px;
      font-size: 18px;
      max-width: 80%;
      text-align: center;
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-transcript.visible {
      opacity: 1;
    }

    /* Landscape orientation specific styles */
    @media (orientation: landscape) and (max-width: 926px) {
      body.auto-fullscreen .container {
        display: none;
      }

      body.auto-fullscreen .fullscreen-mode {
        display: flex;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé¨ ËØ≠Èü≥‰∫§‰∫íËßÜÈ¢ë</h1>
    
    <div class="video-container">
      <video id="mainVideo" preload="auto"></video>
      <div id="voicePrompt" class="voice-prompt">
        <div class="mic-icon">üé§</div>
        <h2>ËØ∑ËØ¥Âá∫‰Ω†ÊÉ≥Êí≠ÊîæÁöÑËßÜÈ¢ë...</h2>
        <p>‰æãÂ¶ÇÔºö"ËßÜÈ¢ë1"„ÄÅ"Á¨¨‰∫å‰∏™"</p>
      </div>
    </div>

    <div class="controls">
      <button id="playBtn">‚ñ∂ Êí≠Êîæ</button>
      <button id="pauseBtn">‚è∏ ÊöÇÂÅú</button>
      <button id="testVoiceBtn">üé§ ÊµãËØïËØ≠Èü≥</button>
      <button id="toggleModeBtn" class="mode-toggle">Ê®°Âºè: DashScope</button>
    </div>

    <div id="status" class="status">ÂáÜÂ§áÂ∞±Áª™</div>

    <div class="transcript-log">
      <h3>üìù ËØÜÂà´ËÆ∞ÂΩï</h3>
      <div id="transcriptLog" class="transcript-content"></div>
    </div>

    <div class="video-list">
      <h3>üìπ ÂèØÁî®ËßÜÈ¢ëÂàóË°®</h3>
      <div id="videoListContainer"></div>
      <div class="preload-info">* ÊâÄÊúâËßÜÈ¢ëÂ∑≤È¢ÑÂä†ËΩΩÔºåÂàáÊç¢Êí≠ÊîæÊõ¥ÊµÅÁïÖ</div>
    </div>
  </div>

  <!-- Fullscreen Mode Container -->
  <div id="fullscreenMode" class="fullscreen-mode">
    <video id="fullscreenVideo" preload="auto"></video>

    <div id="fullscreenStatus" class="fullscreen-status">ÂáÜÂ§áÂ∞±Áª™</div>

    <div id="fullscreenTranscript" class="fullscreen-transcript"></div>

    <div class="fullscreen-controls">
      <button id="fsPlayBtn">‚ñ∂</button>
      <button id="fsPauseBtn">‚è∏</button>
      <button id="fsVoiceBtn">üé§</button>
      <button id="fsExitBtn">‚úï</button>
    </div>
  </div>

  <script>
    // ============================================================================
    // Video Matching System - Modular Architecture
    // ============================================================================

    /**
     * Base class for video matching strategies
     */
    class VideoMatchStrategy {
      constructor(name, priority = 50) {
        this.name = name;
        this.priority = priority; // Higher priority = checked first
      }

      /**
       * Attempt to match transcript to a video
       * @param {string} transcript - The recognized speech text
       * @param {Array} videos - Array of video objects
       * @param {Object} context - Additional context (currentIndex, etc.)
       * @returns {Object|null} - {index: number, confidence: number, reason: string} or null
       */
      match(transcript, videos, context) {
        throw new Error('match() must be implemented by subclass');
      }
    }

    /**
     * Strategy 1: Match by video filename
     */
    class FilenameMatchStrategy extends VideoMatchStrategy {
      constructor() {
        super('Filename Match', 80);
      }

      match(transcript, videos, context) {
        const cleanTranscript = transcript.toLowerCase().trim();

        for (let i = 0; i < videos.length; i++) {
          // Remove extension and convert to lowercase
          const filename = videos[i].name.replace(/\.[^/.]+$/, '').toLowerCase();

          if (cleanTranscript.includes(filename)) {
            return {
              index: i,
              confidence: 0.9,
              reason: `Filename match: "${filename}"`
            };
          }
        }
        return null;
      }
    }

    /**
     * Strategy 2: Match by numeric patterns (ËßÜÈ¢ë1, Á¨¨‰∫å‰∏™, etc.)
     */
    class NumericMatchStrategy extends VideoMatchStrategy {
      constructor() {
        super('Numeric Match', 70);
        this.chineseNumbers = ['‰∏Ä', '‰∫å', '‰∏â', 'Âõõ', '‰∫î', 'ÂÖ≠', '‰∏É', 'ÂÖ´', '‰πù', 'ÂçÅ'];
      }

      numberToChinese(num) {
        return this.chineseNumbers[num - 1] || num.toString();
      }

      match(transcript, videos, context) {
        const cleanTranscript = transcript.toLowerCase().trim();

        for (let i = 0; i < videos.length; i++) {
          const index = i + 1;

          // Pattern 1: "ËßÜÈ¢ë1", "ËßÜÈ¢ë2"
          if (cleanTranscript.includes(`ËßÜÈ¢ë${index}`)) {
            return {
              index: i,
              confidence: 0.95,
              reason: `Numeric pattern: "ËßÜÈ¢ë${index}"`
            };
          }

          // Pattern 2: "Á¨¨‰∏Ä‰∏™", "Á¨¨‰∫å‰∏™"
          if (cleanTranscript.includes(`Á¨¨${this.numberToChinese(index)}‰∏™`)) {
            return {
              index: i,
              confidence: 0.95,
              reason: `Chinese ordinal: "Á¨¨${this.numberToChinese(index)}‰∏™"`
            };
          }

          // Pattern 3: Direct number "1", "2"
          if (cleanTranscript === `${index}`) {
            return {
              index: i,
              confidence: 0.85,
              reason: `Direct number: "${index}"`
            };
          }
        }
        return null;
      }
    }

    /**
     * Strategy 3: Match by video transcript content (simple word matching)
     */
    class TranscriptMatchStrategy extends VideoMatchStrategy {
      constructor() {
        super('Transcript Match', 50); // Lower priority than LLM
      }

      match(transcript, videos, context) {
        const cleanTranscript = transcript.toLowerCase().trim();

        for (let i = 0; i < videos.length; i++) {
          const video = videos[i];

          // Check if video has transcript metadata
          if (!video.transcript) continue;

          const videoTranscript = video.transcript.toLowerCase();

          // Match against beginning of video transcript (first 100 chars)
          const beginning = videoTranscript.substring(0, 100);

          // Check for significant word overlap
          const words = cleanTranscript.split(/\s+/).filter(w => w.length > 1);
          let matchCount = 0;

          for (const word of words) {
            if (beginning.includes(word)) {
              matchCount++;
            }
          }

          // If more than 50% of words match, consider it a match
          if (words.length > 0 && matchCount / words.length > 0.5) {
            return {
              index: i,
              confidence: matchCount / words.length,
              reason: `Transcript match: ${matchCount}/${words.length} words in beginning`
            };
          }

          // Also check full transcript with lower confidence
          matchCount = 0;
          for (const word of words) {
            if (videoTranscript.includes(word)) {
              matchCount++;
            }
          }

          if (words.length > 0 && matchCount / words.length > 0.6) {
            return {
              index: i,
              confidence: (matchCount / words.length) * 0.8,
              reason: `Transcript match: ${matchCount}/${words.length} words in full transcript`
            };
          }
        }
        return null;
      }
    }

    /**
     * Strategy 4: LLM-based conversational matching (FALLBACK)
     * Uses DashScope Qwen to understand conversational context
     * Runs in parallel but only used if other strategies fail
     */
    class LLMConversationalMatchStrategy extends VideoMatchStrategy {
      constructor() {
        super('LLM Conversational Match', 10); // LOW priority - fallback only
      }

      async match(transcript, videos, context) {
        const cleanTranscript = transcript.trim();

        // Filter videos that have transcripts
        const videosWithTranscripts = videos
          .map((v, i) => ({ video: v, index: i }))
          .filter(v => v.video.transcript);

        if (videosWithTranscripts.length === 0) {
          return null; // No transcripts to match against
        }

        try {
          console.log('[LLM] Starting LLM matching in background...');

          // Call LLM via server
          const response = await fetch('/api/llm-match', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              user_speech: cleanTranscript,
              videos: videosWithTranscripts.map(v => ({
                index: v.index,
                name: v.video.name,
                transcript: v.video.transcript
              }))
            })
          });

          if (!response.ok) {
            console.error('[LLM] LLM matching failed:', response.statusText);
            return null;
          }

          const result = await response.json();
          console.log('[LLM] LLM matching complete:', result);

          if (result.matched_index !== null && result.matched_index >= 0) {
            return {
              index: result.matched_index,
              confidence: result.confidence || 0.95,
              reason: `LLM match: ${result.reason || 'Conversational response'}`
            };
          }

          return null;

        } catch (error) {
          console.error('[LLM] LLM matching error:', error);
          return null;
        }
      }

      buildPrompt(userSpeech, videosWithTranscripts) {
        // This is just for reference, actual prompt is built on server
        return `User said: "${userSpeech}"\nWhich video is the best conversational response?`;
      }
    }

    /**
     * Video Matcher - Coordinates all matching strategies
     */
    class VideoMatcher {
      constructor() {
        this.strategies = [];
        this.matchHistory = [];
      }

      /**
       * Register a matching strategy
       */
      addStrategy(strategy) {
        this.strategies.push(strategy);
        // Sort by priority (highest first)
        this.strategies.sort((a, b) => b.priority - a.priority);
      }

      /**
       * Find best matching video for transcript
       * Optimized: Run LLM in parallel but use fast strategies first
       */
      async findMatch(transcript, videos, context = {}) {
        console.log('[VideoMatcher] Starting parallel matching...');

        // Separate strategies into fast and slow
        const fastStrategies = this.strategies.filter(s => s.priority >= 50);
        const llmStrategy = this.strategies.find(s => s.name === 'LLM Conversational Match');

        const results = [];
        let llmPromise = null;

        // Start LLM in background (don't wait)
        if (llmStrategy) {
          console.log('[VideoMatcher] Starting LLM in background...');
          llmPromise = llmStrategy.match(transcript, videos, context)
            .then(result => {
              if (result) {
                console.log('[VideoMatcher] LLM completed:', result);
                return { ...result, strategy: llmStrategy.name };
              }
              return null;
            })
            .catch(error => {
              console.error('[VideoMatcher] LLM failed:', error);
              return null;
            });
        }

        // Try fast strategies first (synchronous)
        console.log('[VideoMatcher] Trying fast strategies...');
        for (const strategy of fastStrategies) {
          try {
            const result = await strategy.match(transcript, videos, context);
            if (result) {
              results.push({
                ...result,
                strategy: strategy.name
              });
              console.log(`[VideoMatcher] Fast match found: ${strategy.name}`);
            }
          } catch (error) {
            console.error(`[VideoMatcher] Strategy ${strategy.name} failed:`, error);
          }
        }

        // If fast strategies found matches, use them immediately
        if (results.length > 0) {
          console.log('[VideoMatcher] Using fast strategy result');
          results.sort((a, b) => b.confidence - a.confidence);
          const bestMatch = results[0];
          this.logMatch(transcript, bestMatch, 'Fast match found');

          // LLM is still running in background, but we don't wait for it
          if (llmPromise) {
            console.log('[VideoMatcher] LLM still running, but not waiting...');
          }

          return bestMatch;
        }

        // No fast matches found, wait for LLM
        console.log('[VideoMatcher] No fast matches, waiting for LLM...');
        if (llmPromise) {
          const llmResult = await llmPromise;
          if (llmResult) {
            console.log('[VideoMatcher] Using LLM fallback result');
            this.logMatch(transcript, llmResult, 'LLM fallback match');
            return llmResult;
          }
        }

        // No matches at all
        console.log('[VideoMatcher] No matches found');
        this.logMatch(transcript, null, 'No match found');
        return null;
      }

      /**
       * Log matching attempt for debugging
       */
      logMatch(transcript, result, status) {
        const entry = {
          timestamp: new Date().toISOString(),
          transcript,
          result,
          status
        };

        this.matchHistory.push(entry);

        // Keep only last 50 entries
        if (this.matchHistory.length > 50) {
          this.matchHistory.shift();
        }

        // Console log
        if (result) {
          console.log(`[VideoMatcher] ‚úÖ ${status}:`, {
            transcript,
            videoIndex: result.index,
            confidence: (result.confidence * 100).toFixed(1) + '%',
            strategy: result.strategy,
            reason: result.reason
          });
        } else {
          console.log(`[VideoMatcher] ‚ùå ${status}:`, { transcript });
        }
      }

      /**
       * Get match history for debugging
       */
      getHistory() {
        return this.matchHistory;
      }
    }

    // ============================================================================
    // Main Application
    // ============================================================================

    class VoiceVideoPlayer {
      constructor() {
        this.mainVideo = document.getElementById('mainVideo');
        this.voicePrompt = document.getElementById('voicePrompt');
        this.status = document.getElementById('status');
        this.videoListContainer = document.getElementById('videoListContainer');
        this.transcriptLog = document.getElementById('transcriptLog');

        // Fullscreen elements
        this.fullscreenMode = document.getElementById('fullscreenMode');
        this.fullscreenVideo = document.getElementById('fullscreenVideo');
        this.fullscreenStatus = document.getElementById('fullscreenStatus');
        this.fullscreenTranscript = document.getElementById('fullscreenTranscript');
        this.isFullscreen = false;

        this.videos = [];
        this.currentIndex = 0;
        this.preloadedVideos = new Map();
        this.isListening = false;

        // Hot words
        this.hotWords = [];
        this.hotWordsEnabled = false;

        // Recognition mode: 'dashscope' or 'browser'
        this.recognitionMode = 'dashscope';

        // WebSocket and streaming audio (for DashScope)
        this.socket = null;
        this.audioContext = null;
        this.mediaStream = null;
        this.scriptProcessor = null;

        // Browser-based recognition (Web Speech API)
        this.browserRecognition = null;

        // Initialize video matcher with strategies
        // Priority order: Fast strategies first, LLM as fallback
        this.videoMatcher = new VideoMatcher();
        this.videoMatcher.addStrategy(new FilenameMatchStrategy());        // Priority: 80
        this.videoMatcher.addStrategy(new NumericMatchStrategy());         // Priority: 70
        this.videoMatcher.addStrategy(new TranscriptMatchStrategy());      // Priority: 50
        this.videoMatcher.addStrategy(new LLMConversationalMatchStrategy()); // Priority: 10 (fallback)

        this.init();
      }

      async init() {
        await this.loadVideos();
        await this.loadHotWords();
        this.setupEventListeners();
        this.preloadNextVideos();
        this.initWebSocket();
        this.initBrowserRecognition();
      }

      initWebSocket() {
        // Connect to WebSocket server for DashScope
        // Use current host and port dynamically
        const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';
        const host = window.location.hostname;
        const port = window.location.port || (protocol === 'https:' ? '443' : '80');
        const socketUrl = `${protocol}//${host}:${port}`;

        console.log('Connecting to WebSocket:', socketUrl);
        this.socket = io(socketUrl);

        this.socket.on('connected', (data) => {
          console.log('WebSocket connected:', data);
          this.logTranscript('Á≥ªÁªü', 'WebSocket Â∑≤ËøûÊé•', 'dashscope');
        });

        this.socket.on('recognition_started', (data) => {
          console.log('Recognition started:', data);
        });

        this.socket.on('recognition_result', (data) => {
          console.log('Recognition result:', data);
          if (data.transcript) {
            this.updateStatus(`üé§ ËØÜÂà´‰∏≠: "${data.transcript}"`);
            this.logTranscript('ÈÉ®ÂàÜÁªìÊûú', data.transcript, 'dashscope');
          }
        });

        this.socket.on('recognition_complete', (data) => {
          console.log('Recognition complete:', data);
          this.logTranscript('ÊúÄÁªàÁªìÊûú', data.transcript, 'dashscope');
          this.handleRecognitionComplete(data.transcript);
        });

        this.socket.on('recognition_error', (data) => {
          console.error('Recognition error:', data);
          this.updateStatus('‚ùå ËØÜÂà´ÈîôËØØ: ' + data.error);
          this.logTranscript('ÈîôËØØ', data.error, 'dashscope');
          this.hideVoicePrompt();
          this.stopVoiceRecognition();
        });

        this.socket.on('recognition_closed', (data) => {
          console.log('Recognition closed:', data);
        });
      }

      initBrowserRecognition() {
        // Initialize Web Speech API
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          console.warn('Browser does not support Web Speech API');
          return;
        }

        this.browserRecognition = new SpeechRecognition();
        this.browserRecognition.lang = 'zh-CN';
        this.browserRecognition.continuous = false;
        this.browserRecognition.interimResults = true;

        this.browserRecognition.onstart = () => {
          console.log('Browser recognition started');
          this.updateStatus('üé§ Ê≠£Âú®Âê¨... (ÊµèËßàÂô®ËØÜÂà´)', 'listening');
        };

        this.browserRecognition.onresult = (event) => {
          let interimTranscript = '';
          let finalTranscript = '';

          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
              finalTranscript += transcript;
              this.logTranscript('ÊúÄÁªàÁªìÊûú', transcript, 'browser');
            } else {
              interimTranscript += transcript;
              this.logTranscript('ÈÉ®ÂàÜÁªìÊûú', transcript, 'browser');
            }
          }

          if (interimTranscript) {
            this.updateStatus(`üé§ ËØÜÂà´‰∏≠: "${interimTranscript}"`);
          }

          if (finalTranscript) {
            console.log('Browser recognition final:', finalTranscript);
            this.handleRecognitionComplete(finalTranscript);
          }
        };

        this.browserRecognition.onerror = (event) => {
          console.error('Browser recognition error:', event.error);
          this.updateStatus('‚ùå ÊµèËßàÂô®ËØÜÂà´ÈîôËØØ: ' + event.error);
          this.logTranscript('ÈîôËØØ', event.error, 'browser');
          this.hideVoicePrompt();
          this.isListening = false;
        };

        this.browserRecognition.onend = () => {
          console.log('Browser recognition ended');
          this.isListening = false;
        };
      }

      logTranscript(label, text, mode) {
        const timestamp = new Date().toLocaleTimeString('zh-CN');
        const entry = document.createElement('div');
        entry.className = `transcript-entry ${mode}`;

        const modeBadge = mode === 'dashscope' ? 'DashScope' : 'ÊµèËßàÂô®';
        const modeClass = mode === 'dashscope' ? 'dashscope' : 'browser';

        entry.innerHTML = `
          <span class="timestamp">${timestamp}</span>
          <span class="mode-badge ${modeClass}">${modeBadge}</span>
          <strong>${label}:</strong> ${text}
        `;

        this.transcriptLog.appendChild(entry);
        this.transcriptLog.scrollTop = this.transcriptLog.scrollHeight;

        // Also log to console
        console.log(`[${mode.toUpperCase()}] ${label}: ${text}`);
      }

      toggleRecognitionMode() {
        this.recognitionMode = this.recognitionMode === 'dashscope' ? 'browser' : 'dashscope';
        const modeBtn = document.getElementById('toggleModeBtn');

        if (this.recognitionMode === 'dashscope') {
          modeBtn.textContent = 'Ê®°Âºè: DashScope';
          modeBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          this.updateStatus('Â∑≤ÂàáÊç¢Âà∞ DashScope ÊµÅÂºèËØÜÂà´Ê®°Âºè');
        } else {
          modeBtn.textContent = 'Ê®°Âºè: ÊµèËßàÂô®';
          modeBtn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
          this.updateStatus('Â∑≤ÂàáÊç¢Âà∞ÊµèËßàÂô®ÂÜÖÁΩÆËØÜÂà´Ê®°Âºè');
        }

        this.logTranscript('Á≥ªÁªü', `ÂàáÊç¢Âà∞ ${this.recognitionMode === 'dashscope' ? 'DashScope' : 'ÊµèËßàÂô®'} Ê®°Âºè`, this.recognitionMode);
      }

      async loadVideos() {
        try {
          const response = await fetch('/api/videos');
          this.videos = await response.json();

          if (this.videos.length === 0) {
            this.updateStatus('ËØ∑Âú® videos ÁõÆÂΩï‰∏≠Ê∑ªÂä† mp4 ËßÜÈ¢ëÊñá‰ª∂');
            return;
          }

          this.renderVideoList();
          this.loadVideo(0);

          // Preload ALL videos for smooth switching
          this.updateStatus(`Ê≠£Âú®È¢ÑÂä†ËΩΩ ${this.videos.length} ‰∏™ËßÜÈ¢ë...`);
          await this.preloadAllVideos();

          this.updateStatus(`Â∑≤Âä†ËΩΩ ${this.videos.length} ‰∏™ËßÜÈ¢ë (ÊµÅÂºèËØÜÂà´Ê®°Âºè)`);
        } catch (error) {
          this.updateStatus('Âä†ËΩΩËßÜÈ¢ëÂàóË°®Â§±Ë¥•: ' + error.message);
        }
      }

      async loadHotWords() {
        try {
          const response = await fetch('/api/hot-words');
          const hotWordsData = await response.json();

          this.hotWords = hotWordsData.hotWords || [];
          this.hotWordsEnabled = hotWordsData.settings?.enabled !== false;

          if (this.hotWords.length > 0) {
            console.log(`‚úÖ Loaded ${this.hotWords.length} hot words`);
            this.hotWords.forEach(hw => {
              console.log(`   - ${hw.word} (weight: ${hw.weight})`);
            });
          } else {
            console.log('‚ö†Ô∏è No hot words configured');
          }
        } catch (error) {
          console.warn('Failed to load hot words:', error.message);
          this.hotWords = [];
          this.hotWordsEnabled = false;
        }
      }

      async preloadAllVideos() {
        console.log(`Preloading ${this.videos.length} videos...`);

        const preloadPromises = this.videos.map((video, index) => {
          return new Promise((resolve) => {
            const videoElement = document.createElement('video');
            videoElement.preload = 'auto';
            videoElement.src = video.url;

            // Store the URL for quick access
            this.preloadedVideos.set(index, video.url);

            // Listen for when enough data is loaded
            videoElement.addEventListener('canplaythrough', () => {
              console.log(`‚úÖ Preloaded video ${index + 1}/${this.videos.length}: ${video.name}`);
              resolve();
            }, { once: true });

            // Also resolve on error to not block other videos
            videoElement.addEventListener('error', (e) => {
              console.warn(`‚ö†Ô∏è Failed to preload video ${index + 1}: ${video.name}`, e);
              resolve();
            }, { once: true });

            // Timeout after 10 seconds per video
            setTimeout(() => {
              console.log(`‚è±Ô∏è Preload timeout for video ${index + 1}: ${video.name}`);
              resolve();
            }, 10000);
          });
        });

        // Wait for all videos to preload (or timeout)
        await Promise.all(preloadPromises);
        console.log('‚úÖ All videos preloaded!');
      }

      renderVideoList() {
        this.videoListContainer.innerHTML = '';
        this.videos.forEach((video, index) => {
          const div = document.createElement('div');
          div.className = 'video-item';
          div.innerHTML = `
            <span>${index + 1}. ${video.name}</span>
            <span style="font-size: 12px; color: #999;">ÁÇπÂáªÊí≠Êîæ</span>
          `;
          div.addEventListener('click', () => this.loadVideo(index));
          this.videoListContainer.appendChild(div);
        });
      }

      loadVideo(index) {
        if (index < 0 || index >= this.videos.length) return;

        this.currentIndex = index;
        const video = this.videos[index];

        // Update both video elements
        this.mainVideo.src = video.url;
        this.mainVideo.load();

        this.fullscreenVideo.src = video.url;
        this.fullscreenVideo.load();

        this.updateVideoListUI();
        this.updateStatus(`Ê≠£Âú®Êí≠Êîæ: ${video.name}`);

        console.log(`Loading video ${index + 1}: ${video.name} (preloaded: ${this.preloadedVideos.has(index)})`);
      }

      preloadNextVideos() {
        // No longer needed - all videos are preloaded at startup
        // Keeping this method for compatibility
      }

      preloadVideo(index) {
        // No longer needed - all videos are preloaded at startup
        // Keeping this method for compatibility
      }

      updateVideoListUI() {
        const items = this.videoListContainer.querySelectorAll('.video-item');
        items.forEach((item, index) => {
          item.classList.toggle('active', index === this.currentIndex);
        });
      }

      setupEventListeners() {
        this.mainVideo.addEventListener('ended', () => {
          this.showVoicePrompt();
          this.startVoiceRecognition();
        });

        document.getElementById('playBtn').addEventListener('click', () => {
          this.mainVideo.play();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
          this.mainVideo.pause();
        });

        document.getElementById('testVoiceBtn').addEventListener('click', () => {
          this.showVoicePrompt();
          this.startVoiceRecognition();
        });

        document.getElementById('toggleModeBtn').addEventListener('click', () => {
          this.toggleRecognitionMode();
        });

        // Fullscreen controls
        document.getElementById('fsPlayBtn').addEventListener('click', () => {
          this.getActiveVideo().play();
        });

        document.getElementById('fsPauseBtn').addEventListener('click', () => {
          this.getActiveVideo().pause();
        });

        document.getElementById('fsVoiceBtn').addEventListener('click', () => {
          this.startVoiceRecognition();
        });

        document.getElementById('fsExitBtn').addEventListener('click', () => {
          this.exitFullscreen();
        });

        // Orientation change detection
        window.addEventListener('orientationchange', () => {
          this.handleOrientationChange();
        });

        // Also listen to resize for better responsiveness
        window.addEventListener('resize', () => {
          this.handleOrientationChange();
        });

        // Show/hide fullscreen controls on interaction
        this.fullscreenMode.addEventListener('click', () => {
          this.toggleFullscreenControls();
        });

        // Keep controls visible while interacting
        const fsControls = document.querySelector('.fullscreen-controls');
        fsControls.addEventListener('mouseenter', () => {
          fsControls.classList.add('visible');
        });
        fsControls.addEventListener('mouseleave', () => {
          setTimeout(() => {
            if (!this.isListening) {
              fsControls.classList.remove('visible');
            }
          }, 3000);
        });
      }

      showVoicePrompt() {
        this.voicePrompt.classList.add('active');
      }

      hideVoicePrompt() {
        this.voicePrompt.classList.remove('active');
      }

      async startVoiceRecognition() {
        if (this.isListening) return;

        // Update fullscreen voice button state
        if (this.isFullscreen) {
          const fsVoiceBtn = document.getElementById('fsVoiceBtn');
          fsVoiceBtn.classList.add('listening');
          this.showFullscreenControls();
        }

        if (this.recognitionMode === 'browser') {
          this.startBrowserRecognition();
        } else {
          this.startDashScopeRecognition();
        }
      }

      startBrowserRecognition() {
        if (!this.browserRecognition) {
          this.updateStatus('‚ùå ÊµèËßàÂô®‰∏çÊîØÊåÅËØ≠Èü≥ËØÜÂà´');
          this.hideVoicePrompt();
          return;
        }

        try {
          this.isListening = true;
          this.browserRecognition.start();
          this.logTranscript('Á≥ªÁªü', 'ÂºÄÂßãÊµèËßàÂô®ËØ≠Èü≥ËØÜÂà´', 'browser');
        } catch (error) {
          this.updateStatus('ÊµèËßàÂô®ËØÜÂà´ÂêØÂä®Â§±Ë¥•: ' + error.message);
          this.logTranscript('ÈîôËØØ', error.message, 'browser');
          this.hideVoicePrompt();
          this.isListening = false;
        }
      }

      async startDashScopeRecognition() {
        if (this.isListening) return;

        try {
          // Get microphone access
          this.mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });

          this.isListening = true;
          this.updateStatus('üé§ Ê≠£Âú®Âê¨... (DashScope ÊµÅÂºèËØÜÂà´)', 'listening');
          this.logTranscript('Á≥ªÁªü', 'ÂºÄÂßã DashScope ÊµÅÂºèËØÜÂà´', 'dashscope');

          // Create AudioContext (let browser choose sample rate, we'll resample)
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

          console.log(`AudioContext sample rate: ${this.audioContext.sampleRate} Hz`);

          const source = this.audioContext.createMediaStreamSource(this.mediaStream);

          // Use ScriptProcessorNode for audio processing
          const bufferSize = 4096;
          this.scriptProcessor = this.audioContext.createScriptProcessor(bufferSize, 1, 1);

          let frameCount = 0;

          this.scriptProcessor.onaudioprocess = (e) => {
            if (!this.isListening) return;

            const inputData = e.inputBuffer.getChannelData(0);

            // Debug: Log first frame
            if (frameCount === 0) {
              console.log('First audio frame:', {
                length: inputData.length,
                sampleRate: this.audioContext.sampleRate,
                firstSamples: Array.from(inputData.slice(0, 10)),
                max: Math.max(...inputData),
                min: Math.min(...inputData)
              });
            }
            frameCount++;

            // Resample to 16kHz if needed
            let resampledData = inputData;
            if (this.audioContext.sampleRate !== 16000) {
              resampledData = this.resample(inputData, this.audioContext.sampleRate, 16000);
            }

            // Convert Float32Array to Int16Array (PCM)
            const pcmData = this.float32ToInt16(resampledData);

            // Send PCM data to server via WebSocket
            if (this.socket && this.socket.connected) {
              this.socket.emit('audio_data', { audio: Array.from(pcmData) });
            }
          };

          source.connect(this.scriptProcessor);
          this.scriptProcessor.connect(this.audioContext.destination);

          // Start recognition on server
          this.socket.emit('start_recognition', {});

          // Stop after 5 seconds
          setTimeout(() => {
            if (this.isListening) {
              this.stopVoiceRecognition();
            }
          }, 5000);

        } catch (error) {
          this.updateStatus('È∫¶ÂÖãÈ£éËÆøÈóÆÂ§±Ë¥•: ' + error.message);
          this.logTranscript('ÈîôËØØ', 'È∫¶ÂÖãÈ£éËÆøÈóÆÂ§±Ë¥•: ' + error.message, 'dashscope');
          this.hideVoicePrompt();
          this.isListening = false;
        }
      }

      stopVoiceRecognition() {
        if (!this.isListening) return;

        this.isListening = false;
        this.updateStatus('üîÑ Ê≠£Âú®Â§ÑÁêÜËØ≠Èü≥...', 'processing');

        // Update fullscreen voice button state
        if (this.isFullscreen) {
          const fsVoiceBtn = document.getElementById('fsVoiceBtn');
          fsVoiceBtn.classList.remove('listening');
        }

        if (this.recognitionMode === 'browser') {
          // Stop browser recognition
          if (this.browserRecognition) {
            try {
              this.browserRecognition.stop();
            } catch (e) {
              console.log('Browser recognition already stopped');
            }
          }
        } else {
          // Stop DashScope recognition
          // Stop audio processing
          if (this.scriptProcessor) {
            this.scriptProcessor.disconnect();
            this.scriptProcessor = null;
          }

          if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
          }

          if (this.mediaStream) {
            this.mediaStream.getTracks().forEach(track => track.stop());
            this.mediaStream = null;
          }

          // Stop recognition on server
          if (this.socket && this.socket.connected) {
            this.socket.emit('stop_recognition', {});
          }
        }
      }

      float32ToInt16(float32Array) {
        const int16Array = new Int16Array(float32Array.length);
        for (let i = 0; i < float32Array.length; i++) {
          const s = Math.max(-1, Math.min(1, float32Array[i]));
          int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return int16Array;
      }

      resample(audioData, fromSampleRate, toSampleRate) {
        // Simple linear interpolation resampling
        if (fromSampleRate === toSampleRate) {
          return audioData;
        }

        const ratio = fromSampleRate / toSampleRate;
        const newLength = Math.round(audioData.length / ratio);
        const result = new Float32Array(newLength);

        for (let i = 0; i < newLength; i++) {
          const position = i * ratio;
          const index = Math.floor(position);
          const fraction = position - index;

          if (index + 1 < audioData.length) {
            // Linear interpolation
            result[i] = audioData[index] * (1 - fraction) + audioData[index + 1] * fraction;
          } else {
            result[i] = audioData[index];
          }
        }

        return result;
      }

      async handleRecognitionComplete(transcript) {
        this.hideVoicePrompt();

        if (!transcript || transcript.trim() === '') {
          this.updateStatus('‚ö†Ô∏è Êú™ËÉΩËØÜÂà´ËØ≠Èü≥ÂÜÖÂÆπÔºåÊí≠Êîæ‰∏ã‰∏Ä‰∏™');
          setTimeout(() => {
            this.playNext();
          }, 2000);
          return;
        }

        const cleanTranscript = transcript.trim().toLowerCase();
        this.updateStatus(`‚úÖ ËØÜÂà´ÁªìÊûú: "${cleanTranscript}"`);

        // Show transcript in fullscreen mode
        if (this.isFullscreen) {
          this.showFullscreenTranscript(`ËØÜÂà´: "${cleanTranscript}"`);
        }

        // Use VideoMatcher to find best match (now async)
        const match = await this.videoMatcher.findMatch(cleanTranscript, this.videos, {
          currentIndex: this.currentIndex
        });

        if (match) {
          // Log match details
          this.logTranscript(
            'ÂåπÈÖçÁªìÊûú',
            `ËßÜÈ¢ë #${match.index + 1} (${match.strategy}, ÁΩÆ‰ø°Â∫¶: ${(match.confidence * 100).toFixed(1)}%)`,
            this.recognitionMode
          );

          this.updateStatus(
            `‚úÖ ÂåπÈÖçÂà∞ËßÜÈ¢ë #${match.index + 1}: ${this.videos[match.index].name} (${(match.confidence * 100).toFixed(1)}% ÁΩÆ‰ø°Â∫¶)`
          );

          setTimeout(() => {
            this.loadVideo(match.index);
            this.getActiveVideo().play();
          }, 1000);
        } else {
          this.logTranscript('ÂåπÈÖçÁªìÊûú', 'Êú™ÊâæÂà∞ÂåπÈÖçÔºåÊí≠Êîæ‰∏ã‰∏Ä‰∏™', this.recognitionMode);
          this.updateStatus(`Êú™ÊâæÂà∞ÂåπÈÖçÁöÑËßÜÈ¢ë "${cleanTranscript}"ÔºåÊí≠Êîæ‰∏ã‰∏Ä‰∏™`);
          setTimeout(() => {
            this.playNext();
          }, 2000);
        }
      }

      playNext() {
        const nextIndex = (this.currentIndex + 1) % this.videos.length;
        this.loadVideo(nextIndex);
        this.getActiveVideo().play();
      }

      updateStatus(message, className = '') {
        this.status.textContent = message;
        this.status.className = 'status ' + className;

        // Also update fullscreen status
        if (this.isFullscreen) {
          this.updateFullscreenStatus(message);
        }
      }

      // ============================================================================
      // Fullscreen Mode Methods
      // ============================================================================

      /**
       * Get the currently active video element (main or fullscreen)
       */
      getActiveVideo() {
        return this.isFullscreen ? this.fullscreenVideo : this.mainVideo;
      }

      /**
       * Handle orientation changes
       */
      handleOrientationChange() {
        // Check if device is in landscape mode
        const isLandscape = window.matchMedia('(orientation: landscape)').matches;
        const isMobile = window.matchMedia('(max-width: 926px)').matches;

        if (isLandscape && isMobile) {
          // Enter fullscreen mode
          this.enterFullscreen();
        } else if (!isLandscape && this.isFullscreen) {
          // Exit fullscreen mode when returning to portrait
          this.exitFullscreen();
        }
      }

      /**
       * Enter fullscreen mode
       */
      enterFullscreen() {
        if (this.isFullscreen) return;

        console.log('Entering fullscreen mode');

        // Sync video state from main to fullscreen
        this.fullscreenVideo.src = this.mainVideo.src;
        this.fullscreenVideo.currentTime = this.mainVideo.currentTime;

        if (!this.mainVideo.paused) {
          this.fullscreenVideo.play();
        }

        // Pause main video
        this.mainVideo.pause();

        // Show fullscreen mode
        this.fullscreenMode.classList.add('active');
        document.body.classList.add('auto-fullscreen');
        this.isFullscreen = true;

        // Show controls briefly
        this.showFullscreenControls();

        // Request native fullscreen API if available
        if (this.fullscreenMode.requestFullscreen) {
          this.fullscreenMode.requestFullscreen().catch(err => {
            console.log('Fullscreen API not available:', err);
          });
        }

        console.log('Fullscreen mode active');
      }

      /**
       * Exit fullscreen mode
       */
      exitFullscreen() {
        if (!this.isFullscreen) return;

        console.log('Exiting fullscreen mode');

        // Sync video state from fullscreen to main
        this.mainVideo.src = this.fullscreenVideo.src;
        this.mainVideo.currentTime = this.fullscreenVideo.currentTime;

        if (!this.fullscreenVideo.paused) {
          this.mainVideo.play();
        }

        // Pause fullscreen video
        this.fullscreenVideo.pause();

        // Hide fullscreen mode
        this.fullscreenMode.classList.remove('active');
        document.body.classList.remove('auto-fullscreen');
        this.isFullscreen = false;

        // Exit native fullscreen if active
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(err => {
            console.log('Error exiting fullscreen:', err);
          });
        }

        console.log('Fullscreen mode exited');
      }

      /**
       * Toggle fullscreen controls visibility
       */
      toggleFullscreenControls() {
        const controls = document.querySelector('.fullscreen-controls');
        controls.classList.toggle('visible');

        // Auto-hide after 3 seconds if not listening
        if (controls.classList.contains('visible') && !this.isListening) {
          setTimeout(() => {
            if (!this.isListening) {
              controls.classList.remove('visible');
            }
          }, 3000);
        }
      }

      /**
       * Show fullscreen controls
       */
      showFullscreenControls() {
        const controls = document.querySelector('.fullscreen-controls');
        controls.classList.add('visible');

        // Auto-hide after 3 seconds
        setTimeout(() => {
          if (!this.isListening) {
            controls.classList.remove('visible');
          }
        }, 3000);
      }

      /**
       * Update fullscreen status message
       */
      updateFullscreenStatus(message) {
        this.fullscreenStatus.textContent = message;
        this.fullscreenStatus.classList.add('visible');

        // Auto-hide after 3 seconds
        setTimeout(() => {
          this.fullscreenStatus.classList.remove('visible');
        }, 3000);
      }

      /**
       * Show transcript in fullscreen mode
       */
      showFullscreenTranscript(text) {
        this.fullscreenTranscript.textContent = text;
        this.fullscreenTranscript.classList.add('visible');

        // Auto-hide after 5 seconds
        setTimeout(() => {
          this.fullscreenTranscript.classList.remove('visible');
        }, 5000);
      }
    }

    // Initialize player
    const player = new VoiceVideoPlayer();
  </script>
</body>
</html>